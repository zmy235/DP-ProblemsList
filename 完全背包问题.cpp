
完全背包问题
有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。
很容易可以得到这种状态表示：用DP[I][J] 表示前I件物品放入一个容量为J的背包可以获得的最大价值。则
DP[I][J]=MAX（DP[I-1][J]，DP[I-1][J-K*C[I]]+K*W[I]） 0<=K*C[I]<=J
这样的复杂度是O(V*Σ(V/c[i]))
有更好的做法，那就是利用01背包的优化原理。在优化的代码中，之所以第二重循环是倒序，是为了防止重复拿，那么只要将其变为顺序即可以重复取。代码就不给了。 
多重背包问题
有N种物品和一个容量为V的背包。第i种物品最多有n[i]件可用，每件费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。
这题仍然可以用到上一题的思想，DP表示状态与上面的相同。方程为：
DP[I][J]=MAX（DP[I-1][J]，DP[I-1][J-K*C[I]]+K*W[I]）
不同的是K的范围，0<=K<=N[I] && 0<=K*C[I]<=J
这样的复杂度为O(V*Σn[i])。
有更好的想法就是先用二进制来划分。将第i种物品分成若干件物品，其中每件物品有一个系数，这件物品的费用和价值均是原来的费用和价值乘以这个系数。使这些系数分别为1,2,4,...,2^(k-1),n[i]-2^k+1，且k是满足n[i]-2^k+1>0的最大整数。然后用01背包做，这样的复杂度为O(V*Σlog n[i])。关键代码：
const int SIZE=1001;
int dp[SIZE];
int num[SIZE],c[SIZE],w[SIZE];  //num[i]是I物品的件数,C[I]是费用，W[I]是价值
int MultiPack(int n,int v) 
{  //存入参数，N是物品种类数，V是背包容量
  int i,j,k;
  memset(dp,0,sizeof(dp));
  for(i=1;i<=n;++i) 
{ //存放物品的数组下标从1开始
  if( c[i]*num[i]>=v ) 
  {
    for(j=c[i];j<=v;++j) 
    {
      dp[j]=MAX(dp[j],dp[j-c[i]]+w[i]);
    }
  }
  else 
{  //使用二进制划分
  k=1;
  while( k<num[i] ) 
  {
    for(j=v;j>=k*c[i];--j) 
    {
      dp[j]=MAX(dp[j],dp[j-k*c[i]]+k*w[i]);
    }
    num[i]-=k;
    k*=2;
  }
  for(j=v;j>=num[i]*c[i];--j) 
  {
    dp[j]=MAX(dp[j],dp[j-num[i]*c[i]]+num[i]*w[i]);
  }
}
}
return dp[v];
}